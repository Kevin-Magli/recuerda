/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a combination of ownership-based and role-based access control.
 * All data is organized into user-owned profiles and publicly readable memorials with owner-only writes.
 *
 * Data Structure:
 * - /users/{userId}: Stores private user profile data, accessible only to the authenticated user.
 * - /memorials/{memorialId}: Stores public memorial page data, readable by everyone, but writable only by the author.
 * - /roles_admin/{userId}: Indicates admin status. The existence of a document grants admin privileges.
 *
 * Key Security Decisions:
 * - Users can only read and write their own user profile data.
 * - Memorial pages are publicly readable but only the author can modify them.
 * - Admin privileges are granted by the presence of a document in the `/roles_admin/{userId}` collection.
 * - Listing of users is not allowed to protect user privacy.
 *
 * Denormalization for Authorization:
 * - Memorial pages contain an `authorId` field, which is used to quickly check ownership without additional reads.
 *
 * Structural Segregation:
 * - Public memorial pages are stored in the top-level `/memorials` collection, separate from private user data under `/users/{userId}`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profiles. Only the authenticated user can read and write their own profile.
     * @path /users/{userId}
     * @allow (get, update, delete) if the requesting user's UID matches the {userId} path parameter.
     * @allow (create) if the requesting user's UID matches the {userId} path parameter.
     * @deny (list) Listing users is not permitted to protect user privacy.
     * @deny (create, update, delete) if the requesting user's UID does not match the {userId} path parameter.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Secure memorial pages. Memorials are publicly readable, but only the author can modify them.
     * @path /memorials/{memorialId}
     * @allow (get, list) Memorials are publicly readable.
     * @allow (create) if the requesting user's UID matches the `authorId` field in the request data.
     * @allow (update, delete) if the requesting user's UID matches the `authorId` field in the existing document.
     * @deny (create, update, delete) if the requesting user's UID does not match the `authorId` field.
     * @principle Enforces document ownership for writes on a publicly readable collection.
     */
    match /memorials/{memorialId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(authorId) {
        return request.auth.uid == authorId;
      }

      function isExistingOwner() {
          return resource.data.authorId == request.auth.uid;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner();
      allow delete: if isSignedIn() && isExistingOwner();
    }

     /**
      * @description Grants admin privileges to a user if a document with their ID exists in this collection. This uses 'Existence over Content'.
      * @path /roles_admin/{userId}
      * @allow (get, list) No need to get or list this collection
      * @allow (create) Anyone can create. This is a prototyping rule. In production, this should be restricted.
      * @allow (update) Anyone can update. This is a prototyping rule. In production, this should be restricted.
      * @allow (delete) Anyone can delete. This is a prototyping rule. In production, this should be restricted.
      * @principle Role-based access control based on document existence.
      */
    match /roles_admin/{userId} {
        allow get: if false;
        allow list: if false;
        allow create: if true; // TODO: In production, restrict this to an admin role.
        allow update: if true; // TODO: In production, restrict this to an admin role.
        allow delete: if true; // TODO: In production, restrict this to an admin role.
    }
  }
}